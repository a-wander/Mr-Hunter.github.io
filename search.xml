<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【C语言】经典小游戏-扫雷]]></title>
    <url>%2F2018%2F05%2F22%2F201855223%2F</url>
    <content type="text"><![CDATA[前言 扫雷，是一个Windows平台下一个经典的小游戏，今有兴趣玩了几把后，就利用所学二维数组的相关知识模拟实现了一个“扫雷游戏”。由于学识浅薄，界面有点简陋，尽请谅解！ 项目思路: 首先想一想扫雷游戏在Windows平台下是如何实现的。 其次通过观察游戏，我们可以想到需要用两个二维数组来实现扫雷的功能。 游戏刚开始，需要需要显示棋盘，用“*”遮盖雷的坐标，所以要有一个填充棋盘的函数。 通过rand()函数，随机生成雷的坐标，埋雷的函数。 每次扫过后，都要显示新的棋盘，显示棋盘的函数。 如果要想第一次踩不到雷的，需要把该坐标下得雷移动到其他不是雷的坐标，并且点击不是雷，还要满足一点击一片的效果。 最后需要一个函数判断是否扫雷成功。 项目展示： 是不是很有意思？当然重中之重的是： 要注意需要用二维数组来打印两个棋盘，假如我们要打印10X10的棋盘，那我们的二维数组元素也要为10X10个吗？，不能，因为我们在设计算法时需要统计坐标周围8个方位雷的个数，假如要统计边界坐标周围雷的个数，那么就会有数组越界的问题，那我们就要在10X10的边界多上一圈元素，也就要定义12X12的数组元素，这些元素我们不要打印出来，心里有数就行。 项目源码：game.h:1234567891011121314151617181920212223242526272829303132333435363738394041424344/********************************************************************************************** 项目名称：扫雷游戏 ** 编译环境：Vs 2013 ** 创建日期：2018.4.18 ** 项目编辑：Mr.Yao * ***********************************************************************************************/ //知识点： //1.数组 //2.函数 //3.循环 //4.扩展内容： 递归 (内存换取时间) #ifndef __GAME_H_ #define __GAME_H_ #include &lt;stdio.h&gt; #include &lt;Windows.h&gt; #include &lt;time.h&gt; #include &lt;string.h&gt; enum opp &#123; EXIT, PLAY &#125;; #define EASY 10 #define HARD 30 #define ROW 10 #define COL 10 #define ROWS (ROW+2) #define COLS (COL+2) void InitMap(char arr[ROWS][COLS], int row,int col, char set); //创建初始化棋盘 void PrintMap(char arr[ROWS][COLS], int row, int col); //打印棋盘 void SetMy(char arr[ROWS][COLS], int row, int col, int count); //布雷 void SweepMap(char my_map[ROWS][COLS], char player_map[ROWS][COLS], int row, int cow, int sum); //扫雷 void MoveLei(char my_map[ROWS][COLS], int x, int y); //若第一次扫到雷，则移动雷的位置 void GetCount(char my_map[ROWS][COLS], char player_map[ROWS][COLS], int x, int y);//统计雷数 #endif game.c:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186#define _CRT_SECURE_NO_WARNINGS 1 #include "game.h" void InitMap(char arr[ROWS][COLS], int row, int col, char set) &#123; memset(arr, set, col*row*sizeof(arr[0][0])); &#125; void PrintMap(char arr[ROWS][COLS], int row, int col) &#123; int i = 0; int j = 0; printf(" "); for (i = 1; i&lt;=row ; i++) &#123; printf("%3d", i); &#125; printf("\n"); for (i = 0; i&lt;=row; i++) &#123; printf("---"); &#125; printf("\n"); for (i = 1; i &lt;= row; i++) &#123; printf("%2d|", i); for (j = 1; j &lt;= col ; j++) &#123; printf("%3c", arr[i][j]); &#125; printf("\n"); &#125; &#125; void SetMy(char arr[ROWS][COLS], int row, int col, int sum) &#123; int count = sum; int x = 0; int y = 0; while (count) &#123; x = rand() % row + 1; y = rand() % col + 1; if (arr[x][y] == '0') &#123; arr[x][y] = '1'; count--; &#125; &#125; &#125; void SweepMap(char my_map[ROWS][COLS],char player_map[ROWS][COLS], int row, int col, int sum) &#123; int x = 0; int y = 0; int count = 0; int temp = 0; int win = 0; while (win &lt; (row * col - sum)) &#123; printf("请输入你扫雷坐标:&gt;"); scanf("%d%d", &amp;x, &amp;y); temp++; if (x &gt;= 1 &amp;&amp; x &lt;= row&amp;&amp;y &gt;= 1 &amp;&amp; y &lt;= col) &#123; while ((my_map[x][y] == '1') &amp;&amp; (temp == 1)) &#123; //保证玩家第一次不死 MoveLei(my_map, x, y); //对周围的雷数进行遍历 GetCount(my_map, player_map, x, y); &#125; if (my_map[x][y] == '1') &#123; printf("\n恭喜你，壮烈牺牲\n"); PrintMap(my_map, ROW, COL); break; &#125; else &#123; GetCount(my_map, player_map, x, y); printf("\n"); win++; &#125; PrintMap(player_map, ROW, COL); &#125; else &#123; printf("坐标输入有误\n"); &#125; &#125; if(win == (row * col - sum)) &#123; printf("恭喜你，排完了\n"); &#125; &#125; //若输入的坐标无雷，则要遍历周围，统计雷数 //若周围无雷，则递归遍历，统计周围雷数 void GetCount(char my_map[ROWS][COLS], char player_map[ROWS][COLS], int x, int y) &#123; if ((my_map[x][y] == '0')) &#123; int count = 0; if (my_map[x - 1][y - 1] == '1') count++; if (my_map[x - 1][y] == '1') count++; if (my_map[x - 1][y + 1] == '1') count++; if (my_map[x][y - 1] == '1') count++; if (my_map[x][y + 1] == '1') count++; if (my_map[x + 1][y - 1] == '1') count++; if (my_map[x + 1][y] == '1') count++; if (my_map[x + 1][y + 1] == '1') count++; player_map[x][y] = (count + '0'); &#125; if (player_map[x][y] == '0') &#123; if (player_map[x - 1][y - 1] == '*') GetCount(my_map, player_map, x - 1, y - 1); if (player_map[x - 1][y] == '*') GetCount(my_map, player_map, x - 1, y); if (player_map[x - 1][y + 1] == '*') GetCount(my_map, player_map, x - 1, y + 1); if (player_map[x][y - 1] == '*') GetCount(my_map, player_map, x, y - 1); if (player_map[x][y + 1] == '*') GetCount(my_map, player_map, x, y + 1); if (player_map[x + 1][y - 1] == '*') GetCount(my_map, player_map, x + 1, y - 1); if (player_map[x + 1][y] == '*') GetCount(my_map, player_map, x + 1, y); if (player_map[x + 1][y + 1] == '*') GetCount(my_map, player_map, x + 1, y + 1); &#125; &#125; //为提高游戏体验，设置玩家第一次无论如何都不会被炸死 void MoveLei(char my_map[ROWS][COLS], int x, int y) &#123; int ret = 1; do &#123; my_map[x][y] = '0'; while (ret) &#123; x = rand() % ROW + 1; y = rand() % COL + 1; if (my_map[x][y] == '0') &#123; my_map[x][y] = '1'; &#125; ret--; &#125; &#125; while (ret); &#125; test.c1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#define _CRT_SECURE_NO_WARNINGS 1 #include "game.h" void GotoXY(int x, int y) //设定输出位置 &#123; COORD c; c.X = x - 1; c.Y = y - 1; SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), c); &#125; void meau() &#123; GotoXY(10, 5); printf("开始游戏\n Let's Go!"); Sleep(1500); system("cls"); printf("**** 《扫雷》 ****\n"); printf("************************\n"); printf("******* 1.play *******\n"); printf("******* 0.exit *******\n"); printf("************************\n"); &#125; void game() &#123; int input = 0; int sum = 0; char my_map[ROWS][COLS]; char player_map[ROWS][COLS]; InitMap(my_map,ROWS,COLS,'0'); InitMap(player_map, ROWS, COLS, '*'); printf("**** 1.Easy 0.Hard *****\n"); scanf("%d", &amp;input); switch (input) &#123; case PLAY: sum = EASY; break; case EXIT: sum = HARD; break; default: printf("输入有误\n"); break; &#125; printf("\n这个棋盘有%d个雷。\n", sum); SetMy(my_map,ROW,COL,sum); PrintMap(player_map, ROW, COL); //PrintMap(my_map, ROW, COL); SweepMap(my_map,player_map ,ROW, COL, sum); system("pause"); &#125; void test() &#123; int input = 0; do &#123; meau(); printf("请选择:&gt;"); scanf("%d", &amp;input); switch (input) &#123; case PLAY: game(); break; case EXIT: break; default: printf("输出有误\n"); &#125; &#125; while (input); &#125;int main() &#123; srand((unsigned)time(NULL)); test(); system("pause"); return 0; &#125; 结语 简单利用C语言做了一个小游戏，如有不正之处，欢迎双击评论！]]></content>
      <categories>
        <category>项目实战</category>
      </categories>
      <tags>
        <tag>扫雷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Git命令】大全]]></title>
    <url>%2F2018%2F05%2F20%2F20180522%2F</url>
    <content type="text"><![CDATA[前言 经过搜集、整理，现得到以下Git相关知识，相互学习，相互促进。 上传日期：2018.5.22 整理员：Hunter git命令学习笔记●配置name和email$ git config –global user.name “your name” $ git config –global user.email “your email@example.com“ //–global是全局参数，表示这个账户上所以的Git仓库都使用这个配置 ●配置别名$ git config –global alias.st status ●各种状态显示不同颜色$ git config –global color.ui true ●创建并成为让Git管理的仓库$ mkdir &lt;文件名&gt; $ cd &lt;文件名&gt; $ git init//初始化一个仓库 $ ls -ah//此命令用于看见隐藏的.git ●将文件添加到Git的仓库里$ git add &lt;文件名&gt; //第一步，把文件放到暂存区 $ git commit -m”本次提交的说明” //把暂存区的所有内容提交到当前分支 ●查看工作区当前状态$ git status ●查看修改内容$ git diff 补充：查看工作区和版本库最新版本的区别 $ git diff HEAD – 文件名 ●回退版本$ git reset –hard HEAD^ //回退上一个版本 $ git reset –hard HEAD^^ //回退上上个版本 $ git reset –hard HEAD~100 //回退上100个版本 $ git reset –hard commit_id //在历史版本里任意穿梭 ●查看历史$ git log//查看提交历史 $ git log –pretty=oneline //查看简单的提交历史 $ git reflog//查看命令历史 ●丢弃工作区的修改$ git checkout – 文件名 //在没有添加到暂存区内 $ git reset HEAD 文件名 $ git checkout – 文件名 //添加到暂存区内 ●删除文件$ rm 文件名 $ git rm 文件名 //确实要删除这个文件 $ git checkout – 文件名 //误删 补充：强制删除未被合并的分支 $ git branch -D 分支名 ●生成ssh秘钥$ ssh-keygen -t rsa -C”youremail@example.com“ ●关联远程库$ git remote add origin git@githup.com:&lt;账户名&gt;/&lt;仓库名&gt;.git ●推送本地内容到远程库$ git push -u origin master //第一次推送需要加 -u参数 $ git push origin master //以后操作不用 -u参数 ●克隆仓库$ git clone git@githup.com:&lt;账户名&gt;/&lt;仓库名&gt;.git ●关于分支的命令$ git branch 分支名 //创建一个新的分支 $ git checkout 分支名 //切换分支 $ git checkout -b 分支名 //创建并切换分支 $ git branch //查看当前分支 $ git merge 分支名 //合并此分支到当前分支(Fast forward模式) $ git merge –no-ff -m”说明文字” 分支名（禁用Fast forward模式） $ git branch -d 分支名 ●查看分支合并情况$ git log –graph=oneline –abbrev-commit ●储存工作现场$ git stash//储存工作现场 $ git stash //储存工作现场的列表 $ git stash apply //恢复工作现场，stash内容不删除 $ git stash drop //删除stash的内容 $ git stash pop //恢复工作现场的同时删除stash内容 $ git stash apply stash@{0} //恢复指定stash ●查看远程库信息$ git remote $ git remote -v //查看更详细的信息 ●推送指定分支$ git push origin 分支名 ●从远程库抓取最新的提交$ git pull ●在本地创建远程分支对应分支$ git checkout -b 分支名 origin/分支名 ●建立本地分支和远程分支的关联$ git checkout -set-upstream 分支名 origin/分支名 ●关于标签的命令$ git tag 标签名 //打一个新的标签 $ git tag //查看所有标签 $ git tag 标签名 commit_id //给任意提交过的版本打标签 $ git show 标签名 //查看标签信息 $ git tag -a 标签名 -m”说明文字” commit_id //创建带有说明的标签 -a指定标签名 -m指定说明文字 $ git push origin 标签名 //推送指定标签 $ git push origin –tags //一次性推送所有标签到远程库 $ git tag -d 标签名 //删除指定标签 $ git push origin:refs/tags/标签名 //删除远程库的标签 git push origin –delete HEAD //删除分支 HEAD $ sudo rm test $ git add -u $ git commit -m “delete test” $ git push //删除服务器文件]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串左右旋转问题]]></title>
    <url>%2F2018%2F05%2F20%2F20180520%2F</url>
    <content type="text"><![CDATA[题目 实现一个函数，可以左旋字符串中的k个字符。 AABCD左旋一个字符得到ABCDA AABCD左旋两个字符得到BCDAA 方法一：【暴力移位法】算法思想：用移的步数作为while循环条件(每移1位完了减1)，1位1位的移动，即只需要一个空的变量来存移出去的字符，而这时变量i已经到了数组最后的空位置，此时把先前移出去的字符再补回来即可123456789101112131415161718192021222324252627282930313233#define _CRT_SECURE_NO_WARNINGS 1 #include &lt;stdio.h&gt; #include &lt;assert.h&gt; #include &lt;string.h&gt; void left_move(char *str, int k) &#123; assert(str); char temp = 0; int len = strlen(str); k = k%len; while (k--) &#123; char *cur = str; temp = *cur; while (*(cur + 1) != '\0') &#123; *cur = *(cur + 1); cur++; &#125; *cur = temp; &#125; &#125; int main() &#123; char arr[] = "abcdef"; int k = 0; scanf("%d", &amp;k); left_move(arr, k); printf("%s", arr); return 0; &#125; 方法二：【三步翻转法】算法思想：以移动的步数为界限，左边字符串整体逆置，右边字符串整体逆置，再整个字符串整体逆置，即需要调用3次整体逆置字符串函数，要注意各个逆置区间的定义 1234567891011121314151617181920212223242526272829303132333435363738#define _CRT_SECURE_NO_WARNINGS 1 #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;assert.h&gt; void reverse(char *left, char*right)//逆序 &#123; assert(left&amp;&amp;right); while (left &lt; right) &#123; char tmp; tmp = *left; *left = *right; *right = tmp; left++, right--; &#125; &#125; void reverse_left(char *str, int k) &#123; int len = 0; assert(str); len = strlen(str); k = k%len; reverse(str, (str + k - 1));//要旋转的k个字符逆序 reverse((str + k), (str + len - 1));//之后的字符逆序 reverse(str, (str + len - 1));//所有的字符逆序 &#125; int main() &#123; int k = 0; char str[] = "abcdefgh"; scanf("%d", &amp;k); reverse_left(str, k); printf("%s", str); return 0; &#125; 方法三：【穷举法】算法思想：(相当于穷举法)申请一个是原来2倍+1(算上\0)的数组空间，将原来的字符串复制一遍存在这个空间里，然后从原来的首元素加上移动的步数开始输出len个长度的字符串，完成左旋效果(先后用到strcpy strcat strncpy函数) 注意：(1)变量定义一定要放在表达式前面，否则乱报错；(2)用malloc函数申请完空间记得释放，头文件&lt;stdlib.h&gt;123456789101112131415161718192021222324252627#define _CRT_SECURE_NO_WARNINGS 1 #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;assert.h&gt; void reverse_string(char *str, int k) &#123; int len = strlen(str); char *tmp = (char*)malloc(2 * len + 1); //申请2倍的原数组空间 assert(str); strcpy(tmp, str); //把原来的字符串拷贝到这个大空间里 strcat(tmp, str); //把原来的字符串再拼接到后面(复制2遍) strncpy(str, tmp + k, len); //从要移动的位数后一位起，获取原来长度的字符串，达到左旋效果 free(tmp); &#125; int main() &#123; char arr[] = "abcdef"; int k = 0; scanf("%d", &amp;k); reverse_string(arr, k); printf("%s", arr); return 0; &#125; 结语考查字符串和字符数组的相关操作，注意在没有明确指定是否允许使用库函数的时候，就默认允许使用库函数，在不允许的情况下需要自定义实现这些函数（本题中只需要自定义实现strlen()、strstr()、strcat()这些函数），这样就很OK了！]]></content>
      <categories>
        <category>C语言知识及题集</category>
      </categories>
      <tags>
        <tag>字符串旋转</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析（命令行参数 ）&&（main函数参数）]]></title>
    <url>%2F2018%2F05%2F20%2F201852222-2%2F</url>
    <content type="text"><![CDATA[前言命令行参数: ● 命令行参数是控制命令执行的一种方式。 ● 命令行参数类似于函数的参数，只是命令行参数是传送给命令的。命令执行时，内核已经将命令行参数放入命令的栈中，命令执行时则可以获取命令行参数，解析，执行。 ● 命令行参数使命令可以执行不同任务。 linux系统下的实现:12345678910111213#include &lt;stdio.h&gt; int main(int argc, char *argv[]) &#123; printf("%d\n",argc); printf("%s\n",argv[0]); printf("%s\n",argv[1]); printf("%s\n",argv[2]); &#125; 在这个例子中，我们给main函数传递两个参数：argc，argv： ● argc是int类型的，它表示的是命令行参数的个数。不许要用户传递，它会根据用户从命令行输入的参数个数，自动确定。 ● argv是char* argv[]类型的，即是指针数组类型，它的作用是存储用户从命令行传递进来的参数。它的第一个成员是程序执行的.exe文件。 ● main函数还有一个参数是envp，是一个 指针数组类型，每个元素存储指向一个环境变量的字符指针。这里不予赘述。 对于上面的例子，我们将其保存为test.c，用gcc编译生成目标文件为a.out 编译结果如下： 执行结果如下： 这里第一个输出的是argc，因为我们只输入了./a.out，所以argc为1，即只有一个命令行参数。后面输出的第一个命令行参数也是./a.out。接着程序就出错了，因为程序要说输出第二、第三参数，而后面已经没有第二个和第三个参数了，在写实际的应用时，应注意对这一部分进行容错处理。所谓容错处理就是指软件运行时，能对由非正常因素引起的运行错误给出适当的处理或信息提示，使软件运行正常结束。而这个错误也就是程序员很容易犯得段错误。 当在命令行输入./a.out、linux、nihao三个参数时，执行结果如图： 命令行参数个数为3，第一个参数./a.out、第二个参数linux、第三个参数nihao。 当输入./a.out、”linux nihao”、hehe、”hi apple”四个参数时，执行结果如图： 当输入四个参数，命令行参数个数就为4，但需要注意的是就是如果一个参数之间有空格，需要用双引号引起来，以免产生不必要的错误。 当然对于具体情况请看下图： 结语 对于main函数第二个参数argv，其数据类型可以写成三种形式：char *argv[]、char **argv、char argv[][]，当然第三个函数参数envp同理。]]></content>
      <categories>
        <category>C语言知识及题集</category>
      </categories>
      <tags>
        <tag>命令行参数 main函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My First Blog]]></title>
    <url>%2F2018%2F05%2F20%2FMy-First-Blog%2F</url>
    <content type="text"><![CDATA[前言 人生，走着走着便懂了，对于未来，不再迷茫彷徨，而是以更坚定的步伐迈向预定的目标；人生，走着走着便懂了，对于爱情，不再痴迷悲伤，而是以更理智的心态去接受爱情细水长流的平淡；人生，走着走着便懂了，对于生活，不再困惑感伤，而是以积极乐观的心态去迎接每一个黎明的到来。 白驹过隙，转眼间，我已是大二学生，虽然已经在大学生活了一年，却依然对未来很迷茫，这种迷茫也带来了一系列的恐惧：能否找到称心如意的工作、能否有能力赡养自己的父母，买不起房怎么办、程序员真的是青春饭吗……我是通信学院物联网工程专业的一名普通的不能再普通的学生。说实话，上大学以来，我并没有为了某些事情真正地努力过，即使是一些很简单的事情 。 曾听人说大学有四个阶段：不知道自己不知道-&gt;知道自己不知道-&gt;不知道自己知道-&gt;知道自己知道。就目前情况来看我应该处于第二阶段，我认识到自己缺乏太多的专业知识以及社交原则，我也会经常阅读搞IT的成功人士的案例来寻求安慰与激励，但这只是短暂的麻痹罢了。 曾经很“牛逼”地对好朋友说过：“我不想过一辈子穷苦生活！”现在想起当时的自己真的是既无知又可笑，我特么拿什么去过理想中的生活呢？殊不知：开水不响，响水不开。被打的人才会大吼几声来搏回一点颜面，而真正有实力的人都是深藏不露的。 小时候家里还种地的时候，我也像其他孩子一样要去田里除草。烈日炎炎下，站在田地里往前一看，我的妈，还有这么多的草要拔呀！还没干活便没了一半的力气。而如果一步一步的做好眼前的这一块，便在不知不觉中就到了地头。我现在何尝又不是当年那个拔草的少年呢，我还有海量的东西要学，我为何不能脚踏实地的学好现在的东西呢？ 现于公元二零一八年，特写此篇 ，抒己所感。我并不是为自己起初愚笨忏悔，而是把压在心里的东西排出来轻松一下，并且要警示自己从现在起，静下心来，虚心学习，因为仅剩的大学时光不多了。说实话，像我这样无实力的人连现在的生活都掌控不好，有何权利去畅想未来？关键是要把自己变强大，才能在困难面前有获胜的筹码。曾听过一句自认为非常好的话，毅然当作了自己的座右铭：人生在勤，不索何获！ 作此篇亦献给正处于迷茫中的你，希望能够共勉，一起进步!]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>人生在勤，不索何获</tag>
      </tags>
  </entry>
</search>
